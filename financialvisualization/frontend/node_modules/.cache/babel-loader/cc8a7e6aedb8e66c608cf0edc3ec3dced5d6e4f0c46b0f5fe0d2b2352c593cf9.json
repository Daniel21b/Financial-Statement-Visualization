{"ast":null,"code":"import Queue from 'yocto-queue';\nexport default function pLimit(concurrency) {\n  validateConcurrency(concurrency);\n  const queue = new Queue();\n  let activeCount = 0;\n  const resumeNext = () => {\n    if (activeCount < concurrency && queue.size > 0) {\n      queue.dequeue()();\n      // Since `pendingCount` has been decreased by one, increase `activeCount` by one.\n      activeCount++;\n    }\n  };\n  const next = () => {\n    activeCount--;\n    resumeNext();\n  };\n  const run = async (function_, resolve, arguments_) => {\n    const result = (async () => function_(...arguments_))();\n    resolve(result);\n    try {\n      await result;\n    } catch {}\n    next();\n  };\n  const enqueue = (function_, resolve, arguments_) => {\n    // Queue `internalResolve` instead of the `run` function\n    // to preserve asynchronous context.\n    new Promise(internalResolve => {\n      queue.enqueue(internalResolve);\n    }).then(run.bind(undefined, function_, resolve, arguments_));\n    (async () => {\n      // This function needs to wait until the next microtask before comparing\n      // `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n      // after the `internalResolve` function is dequeued and called. The comparison in the if-statement\n      // needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n      await Promise.resolve();\n      if (activeCount < concurrency) {\n        resumeNext();\n      }\n    })();\n  };\n  const generator = function (function_) {\n    for (var _len = arguments.length, arguments_ = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      arguments_[_key - 1] = arguments[_key];\n    }\n    return new Promise(resolve => {\n      enqueue(function_, resolve, arguments_);\n    });\n  };\n  Object.defineProperties(generator, {\n    activeCount: {\n      get: () => activeCount\n    },\n    pendingCount: {\n      get: () => queue.size\n    },\n    clearQueue: {\n      value() {\n        queue.clear();\n      }\n    },\n    concurrency: {\n      get: () => concurrency,\n      set(newConcurrency) {\n        validateConcurrency(newConcurrency);\n        concurrency = newConcurrency;\n        queueMicrotask(() => {\n          // eslint-disable-next-line no-unmodified-loop-condition\n          while (activeCount < concurrency && queue.size > 0) {\n            resumeNext();\n          }\n        });\n      }\n    }\n  });\n  return generator;\n}\nfunction validateConcurrency(concurrency) {\n  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n    throw new TypeError('Expected `concurrency` to be a number from 1 and up');\n  }\n}","map":{"version":3,"names":["Queue","pLimit","concurrency","validateConcurrency","queue","activeCount","resumeNext","size","dequeue","next","run","function_","resolve","arguments_","result","enqueue","Promise","internalResolve","then","bind","undefined","generator","_len","arguments","length","Array","_key","Object","defineProperties","get","pendingCount","clearQueue","value","clear","set","newConcurrency","queueMicrotask","Number","isInteger","POSITIVE_INFINITY","TypeError"],"sources":["/Users/danielberhane/Desktop/Financial Statement Visualization/financialvisualization/node_modules/p-limit/index.js"],"sourcesContent":["import Queue from 'yocto-queue';\n\nexport default function pLimit(concurrency) {\n\tvalidateConcurrency(concurrency);\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst resumeNext = () => {\n\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\tqueue.dequeue()();\n\t\t\t// Since `pendingCount` has been decreased by one, increase `activeCount` by one.\n\t\t\tactiveCount++;\n\t\t}\n\t};\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tresumeNext();\n\t};\n\n\tconst run = async (function_, resolve, arguments_) => {\n\t\tconst result = (async () => function_(...arguments_))();\n\n\t\tresolve(result);\n\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\tnext();\n\t};\n\n\tconst enqueue = (function_, resolve, arguments_) => {\n\t\t// Queue `internalResolve` instead of the `run` function\n\t\t// to preserve asynchronous context.\n\t\tnew Promise(internalResolve => {\n\t\t\tqueue.enqueue(internalResolve);\n\t\t}).then(\n\t\t\trun.bind(undefined, function_, resolve, arguments_),\n\t\t);\n\n\t\t(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// after the `internalResolve` function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve();\n\n\t\t\tif (activeCount < concurrency) {\n\t\t\t\tresumeNext();\n\t\t\t}\n\t\t})();\n\t};\n\n\tconst generator = (function_, ...arguments_) => new Promise(resolve => {\n\t\tenqueue(function_, resolve, arguments_);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount,\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size,\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue() {\n\t\t\t\tqueue.clear();\n\t\t\t},\n\t\t},\n\t\tconcurrency: {\n\t\t\tget: () => concurrency,\n\n\t\t\tset(newConcurrency) {\n\t\t\t\tvalidateConcurrency(newConcurrency);\n\t\t\t\tconcurrency = newConcurrency;\n\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t// eslint-disable-next-line no-unmodified-loop-condition\n\t\t\t\t\twhile (activeCount < concurrency && queue.size > 0) {\n\t\t\t\t\t\tresumeNext();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t},\n\t});\n\n\treturn generator;\n}\n\nfunction validateConcurrency(concurrency) {\n\tif (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
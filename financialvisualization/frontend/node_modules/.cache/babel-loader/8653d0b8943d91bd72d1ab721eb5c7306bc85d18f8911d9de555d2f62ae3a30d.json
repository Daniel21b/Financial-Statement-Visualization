{"ast":null,"code":"import _classPrivateFieldInitSpec from \"/Users/danielberhane/Desktop/Financial Statement Visualization/financialvisualization/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldSet from \"/Users/danielberhane/Desktop/Financial Statement Visualization/financialvisualization/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nimport _classPrivateFieldGet from \"/Users/danielberhane/Desktop/Financial Statement Visualization/financialvisualization/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _defineProperty from \"/Users/danielberhane/Desktop/Financial Statement Visualization/financialvisualization/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n  constructor(value) {\n    _defineProperty(this, \"value\", void 0);\n    _defineProperty(this, \"next\", void 0);\n    this.value = value;\n  }\n}\nvar _head = /*#__PURE__*/new WeakMap();\nvar _tail = /*#__PURE__*/new WeakMap();\nvar _size = /*#__PURE__*/new WeakMap();\nexport default class Queue {\n  constructor() {\n    _classPrivateFieldInitSpec(this, _head, void 0);\n    _classPrivateFieldInitSpec(this, _tail, void 0);\n    _classPrivateFieldInitSpec(this, _size, void 0);\n    this.clear();\n  }\n  enqueue(value) {\n    var _this$size, _this$size2;\n    const node = new Node(value);\n    if (_classPrivateFieldGet(_head, this)) {\n      _classPrivateFieldGet(_tail, this).next = node;\n      _classPrivateFieldSet(_tail, this, node);\n    } else {\n      _classPrivateFieldSet(_head, this, node);\n      _classPrivateFieldSet(_tail, this, node);\n    }\n    _classPrivateFieldSet(_size, this, (_this$size = _classPrivateFieldGet(_size, this), _this$size2 = _this$size++, _this$size)), _this$size2;\n  }\n  dequeue() {\n    var _this$size3, _this$size4;\n    const current = _classPrivateFieldGet(_head, this);\n    if (!current) {\n      return;\n    }\n    _classPrivateFieldSet(_head, this, _classPrivateFieldGet(_head, this).next);\n    _classPrivateFieldSet(_size, this, (_this$size3 = _classPrivateFieldGet(_size, this), _this$size4 = _this$size3--, _this$size3)), _this$size4;\n    return current.value;\n  }\n  peek() {\n    if (!_classPrivateFieldGet(_head, this)) {\n      return;\n    }\n    return _classPrivateFieldGet(_head, this).value;\n\n    // TODO: Node.js 18.\n    // return this.#head?.value;\n  }\n  clear() {\n    _classPrivateFieldSet(_head, this, undefined);\n    _classPrivateFieldSet(_tail, this, undefined);\n    _classPrivateFieldSet(_size, this, 0);\n  }\n  get size() {\n    return _classPrivateFieldGet(_size, this);\n  }\n  *[Symbol.iterator]() {\n    let current = _classPrivateFieldGet(_head, this);\n    while (current) {\n      yield current.value;\n      current = current.next;\n    }\n  }\n}","map":{"version":3,"names":["Node","constructor","value","_defineProperty","_head","WeakMap","_tail","_size","Queue","_classPrivateFieldInitSpec","clear","enqueue","_this$size","_this$size2","node","_classPrivateFieldGet","next","_classPrivateFieldSet","dequeue","_this$size3","_this$size4","current","peek","undefined","size","Symbol","iterator"],"sources":["/Users/danielberhane/Desktop/Financial Statement Visualization/financialvisualization/node_modules/p-limit/node_modules/yocto-queue/index.js"],"sourcesContent":["/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n\tvalue;\n\tnext;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n}\n\nexport default class Queue {\n\t#head;\n\t#tail;\n\t#size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this.#head) {\n\t\t\tthis.#tail.next = node;\n\t\t\tthis.#tail = node;\n\t\t} else {\n\t\t\tthis.#head = node;\n\t\t\tthis.#tail = node;\n\t\t}\n\n\t\tthis.#size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this.#head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#head = this.#head.next;\n\t\tthis.#size--;\n\t\treturn current.value;\n\t}\n\n\tpeek() {\n\t\tif (!this.#head) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.#head.value;\n\n\t\t// TODO: Node.js 18.\n\t\t// return this.#head?.value;\n\t}\n\n\tclear() {\n\t\tthis.#head = undefined;\n\t\tthis.#tail = undefined;\n\t\tthis.#size = 0;\n\t}\n\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this.#head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n}\n"],"mappings":";;;;AAAA;AACA;AACA;AACA;;AAEA,MAAMA,IAAI,CAAC;EAIVC,WAAWA,CAACC,KAAK,EAAE;IAAAC,eAAA;IAAAA,eAAA;IAClB,IAAI,CAACD,KAAK,GAAGA,KAAK;EACnB;AACD;AAAC,IAAAE,KAAA,oBAAAC,OAAA;AAAA,IAAAC,KAAA,oBAAAD,OAAA;AAAA,IAAAE,KAAA,oBAAAF,OAAA;AAED,eAAe,MAAMG,KAAK,CAAC;EAK1BP,WAAWA,CAAA,EAAG;IAJdQ,0BAAA,OAAAL,KAAK;IACLK,0BAAA,OAAAH,KAAK;IACLG,0BAAA,OAAAF,KAAK;IAGJ,IAAI,CAACG,KAAK,CAAC,CAAC;EACb;EAEAC,OAAOA,CAACT,KAAK,EAAE;IAAA,IAAAU,UAAA,EAAAC,WAAA;IACd,MAAMC,IAAI,GAAG,IAAId,IAAI,CAACE,KAAK,CAAC;IAE5B,IAAIa,qBAAA,CAAKX,KAAK,EAAV,IAAS,CAAC,EAAE;MACfW,qBAAA,CAAKT,KAAK,EAAV,IAAS,CAAC,CAACU,IAAI,GAAGF,IAAI;MACtBG,qBAAA,CAAKX,KAAK,EAAV,IAAI,EAASQ,IAAJ,CAAC;IACX,CAAC,MAAM;MACNG,qBAAA,CAAKb,KAAK,EAAV,IAAI,EAASU,IAAJ,CAAC;MACVG,qBAAA,CAAKX,KAAK,EAAV,IAAI,EAASQ,IAAJ,CAAC;IACX;IAEAG,qBAAA,CAAKV,KAAK,EAAV,IAAI,GAAAK,UAAA,GAAJG,qBAAA,CAAKR,KAAK,EAAV,IAAS,CAAC,EAAAM,WAAA,GAAAD,UAAA,IAAAA,UAAA,CAAD,CAAC,EAAAC,WAAA;EACX;EAEAK,OAAOA,CAAA,EAAG;IAAA,IAAAC,WAAA,EAAAC,WAAA;IACT,MAAMC,OAAO,GAAGN,qBAAA,CAAKX,KAAK,EAAV,IAAS,CAAC;IAC1B,IAAI,CAACiB,OAAO,EAAE;MACb;IACD;IAEAJ,qBAAA,CAAKb,KAAK,EAAV,IAAI,EAASW,qBAAA,CAAKX,KAAK,EAAV,IAAS,CAAC,CAACY,IAAf,CAAC;IACVC,qBAAA,CAAKV,KAAK,EAAV,IAAI,GAAAY,WAAA,GAAJJ,qBAAA,CAAKR,KAAK,EAAV,IAAS,CAAC,EAAAa,WAAA,GAAAD,WAAA,IAAAA,WAAA,CAAD,CAAC,EAAAC,WAAA;IACV,OAAOC,OAAO,CAACnB,KAAK;EACrB;EAEAoB,IAAIA,CAAA,EAAG;IACN,IAAI,CAACP,qBAAA,CAAKX,KAAK,EAAV,IAAS,CAAC,EAAE;MAChB;IACD;IAEA,OAAOW,qBAAA,CAAKX,KAAK,EAAV,IAAS,CAAC,CAACF,KAAK;;IAEvB;IACA;EACD;EAEAQ,KAAKA,CAAA,EAAG;IACPO,qBAAA,CAAKb,KAAK,EAAV,IAAI,EAASmB,SAAJ,CAAC;IACVN,qBAAA,CAAKX,KAAK,EAAV,IAAI,EAASiB,SAAJ,CAAC;IACVN,qBAAA,CAAKV,KAAK,EAAV,IAAI,EAAS,CAAJ,CAAC;EACX;EAEA,IAAIiB,IAAIA,CAAA,EAAG;IACV,OAAOT,qBAAA,CAAKR,KAAK,EAAV,IAAS,CAAC;EAClB;EAEA,EAAGkB,MAAM,CAACC,QAAQ,IAAI;IACrB,IAAIL,OAAO,GAAGN,qBAAA,CAAKX,KAAK,EAAV,IAAS,CAAC;IAExB,OAAOiB,OAAO,EAAE;MACf,MAAMA,OAAO,CAACnB,KAAK;MACnBmB,OAAO,GAAGA,OAAO,CAACL,IAAI;IACvB;EACD;AACD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}